CREATE OR REPLACE FUNCTION pgr_aDijkstraFromAtoB(
                IN tbl varchar,
                IN st_x double precision,
                IN st_y double precision,
                IN end_x double precision,
                IN end_y double precision,
                OUT seq integer,
                OUT node integer,
                OUT edge integer,
                OUT heading double precision,
                OUT cost double precision,
                OUT geom geometry
        )
        RETURNS SETOF record AS
$BODY$
DECLARE
        sql     text;
        rec     record;
        source	integer;
        target	integer;
        --point	integer;
        
BEGIN
	-- Find nearest node
	EXECUTE 'SELECT id::integer FROM ways_vertices_pgr 
			ORDER BY the_geom <-> ST_GeometryFromText(''POINT(' 
			|| st_x || ' ' || st_y || ')'',4326) LIMIT 1' INTO rec;
	source := rec.id;
	
	EXECUTE 'SELECT id::integer FROM ways_vertices_pgr 
			ORDER BY the_geom <-> ST_GeometryFromText(''POINT(' 
			|| end_x || ' ' || end_y || ')'',4326) LIMIT 1' INTO rec;
	target := rec.id;
	
	-- Shortest path query (TODO: limit extent by BBOX) 
        seq := 0;
        
        sql := 'SELECT seq, id1 AS node, id2 AS edge, cost, the_geom FROM ' ||
                        'pgr_dijkstra(''SELECT id, source, target, st_length(the_geom) as cost FROM '
                                        || quote_ident(tbl) || ''', '
                                        || source || ', ' || target 
                                        || ' , false, false) as pgr JOIN '
                                || quote_ident(tbl) || ' pt ON pgr.id2 = pt.id';

                               
                        
 
	-- Remember start point
        --point := source;
	
        FOR rec IN EXECUTE sql
        LOOP
		
		-- Return record
                seq     := seq + 1;
                node     := rec.node;
                edge    := rec.edge;
                cost    := rec.cost;
                geom    := rec.the_geom;
           
                RETURN NEXT;
                
        END LOOP;
        RETURN;
	
END;
$BODY$
LANGUAGE 'plpgsql' VOLATILE STRICT;

-- SELECT geom into test2 FROM pgr_aDijkstraFromAtoB('ways', 8.677841, 50.1231, 8.683957, 50.125071)


CREATE OR REPLACE FUNCTION pgr_aDijkstraFromAtoB(
    IN tbl VARCHAR,
    IN st_x DOUBLE PRECISION,
    IN st_y DOUBLE PRECISION,
    IN end_x DOUBLE PRECISION,
    IN end_y DOUBLE PRECISION,
    IN wormholes_table VARCHAR DEFAULT NULL,
    IN time_nodes_table VARCHAR DEFAULT NULL,
    OUT seq INTEGER,
    OUT node INTEGER,
    OUT edge INTEGER,
    OUT heading DOUBLE PRECISION,
    OUT cost DOUBLE PRECISION,
    OUT geom GEOMETRY,
    OUT travel_time INTERVAL
) RETURNS SETOF RECORD AS
$BODY$
DECLARE
    sql TEXT;
    rec RECORD;
    source INTEGER;
    target INTEGER;
    graph_sql TEXT;
    geom_sql TEXT;
    time_travel_sql TEXT;
BEGIN
    -- Find nearest node to start point
    EXECUTE '
        SELECT id::INTEGER 
        FROM ways_vertices_pgr 
        ORDER BY the_geom <-> ST_SetSRID(ST_Point(' || st_x || ', ' || st_y || '), 4326)
        LIMIT 1' INTO rec;
    source := rec.id;

    -- Find nearest node to end point
    EXECUTE '
        SELECT id::INTEGER 
        FROM ways_vertices_pgr 
        ORDER BY the_geom <-> ST_SetSRID(ST_Point(' || end_x || ', ' || end_y || '), 4326)
        LIMIT 1' INTO rec;
    target := rec.id;

    -- Build base graph SQL (spatial edges)
    graph_sql := '
        SELECT id, source, target, 
               ST_Length(the_geom) AS cost,
               NULL::INTERVAL AS time_cost
        FROM ' || quote_ident(tbl);

    -- Add wormholes if table provided (parallel paths)
    IF wormholes_table IS NOT NULL THEN
        graph_sql := graph_sql || '
        UNION ALL
        SELECT id, source, target, 
               0 AS cost,  -- Instantaneous travel
               NULL::INTERVAL AS time_cost
        FROM ' || quote_ident(wormholes_table);
    END IF;

    -- Add time travel edges if table provided (temporal jumps)
    IF time_nodes_table IS NOT NULL THEN
        time_travel_sql := '
        UNION ALL
        SELECT -id AS id,  -- Negative ID to avoid conflict
               node AS source,
               node AS target,  -- Same node (temporal jump)
               abs_time_cost AS cost,  -- Absolute time jump cost
               time_jump AS time_cost
        FROM ' || quote_ident(time_nodes_table);

        graph_sql := graph_sql || time_travel_sql;
    END IF;

    -- Combine geometry sources for final output
    geom_sql := '
        SELECT id, the_geom 
        FROM ' || quote_ident(tbl);

    IF wormholes_table IS NOT NULL THEN
        geom_sql := geom_sql || '
        UNION ALL
        SELECT id, the_geom
        FROM ' || quote_ident(wormholes_table);
    END IF;

    -- Main routing query with time-aware cost
    sql := '
        WITH graph AS (' || graph_sql || '),
        dijkstra AS (
            SELECT * 
            FROM pgr_dijkstra(
                $$SELECT id, source, target, cost FROM graph$$,
                ' || source || ', ' || target || ', 
                directed := false
            )
        )
        SELECT d.seq, d.node, d.edge, 
               g.time_cost AS travel_time,
               d.cost,
               COALESCE(geo.the_geom, ST_MakeLine(
                   (SELECT the_geom FROM ways_vertices_pgr WHERE id = d.node),
                   (SELECT the_geom FROM ways_vertices_pgr WHERE id = d.node)
               )) AS geom
        FROM dijkstra d
        LEFT JOIN graph g ON d.edge = g.id
        LEFT JOIN (' || geom_sql || ') geo 
            ON d.edge = geo.id';

    seq := 0;
    FOR rec IN EXECUTE sql
    LOOP
        seq := seq + 1;
        node := rec.node;
        edge := rec.edge;
        cost := rec.cost;
        geom := rec.geom;
        travel_time := rec.travel_time;
        heading := 0;  -- Simplified for this example

        RETURN NEXT;
    END LOOP;
    RETURN;
END;
$BODY$
LANGUAGE plpgsql VOLATILE STRICT;